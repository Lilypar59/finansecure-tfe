name: Deploy to AWS

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

env:
  AWS_REGION: eu-west-1
  ECR_REGISTRY_PREFIX: finansecure
  TERRAFORM_VERSION: 1.5.7

jobs:
  # ==================================================
  # Job: Build Docker Images
  # ==================================================
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    outputs:
      auth-service-image: ${{ steps.build.outputs.auth-service-image }}
      transactions-service-image: ${{ steps.build.outputs.transactions-service-image }}
      nginx-image: ${{ steps.build.outputs.nginx-image }}

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: github-actions-build

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: 'true'

      - name: Get commit hash
        id: commit
        run: echo "hash=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Get branch name
        id: branch
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "name=prod" >> $GITHUB_OUTPUT
          else
            echo "name=dev" >> $GITHUB_OUTPUT
          fi

      # ==================================================
      # Build Auth Service
      # ==================================================
      - name: Build Auth Service
        id: build-auth
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REGISTRY_PREFIX }}/auth-service
          IMAGE_TAG: ${{ steps.commit.outputs.hash }}
        run: |
          docker build \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            -f FinanSecure.Auth/Dockerfile \
            .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # ==================================================
      # Build Transactions Service
      # ==================================================
      - name: Build Transactions Service
        id: build-transactions
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REGISTRY_PREFIX }}/transactions-service
          IMAGE_TAG: ${{ steps.commit.outputs.hash }}
        run: |
          docker build \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            -f FinanSecure.Transactions/Dockerfile \
            .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # ==================================================
      # Build NGINX Image
      # ==================================================
      - name: Build NGINX Image
        id: build-nginx
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REGISTRY_PREFIX }}/nginx
          IMAGE_TAG: ${{ steps.commit.outputs.hash }}
        run: |
          docker build \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            -f finansecure-web/Dockerfile \
            finansecure-web/
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  # ==================================================
  # Job: Deploy DEV
  # ==================================================
  deploy-dev:
    name: Deploy to DEV
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'dev'
    needs: build
    environment:
      name: dev
      url: http://${{ steps.terraform.outputs.alb_dns_name }}

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: github-actions-deploy-dev

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Create S3 backend bucket (if not exists)
        run: |
          aws s3api head-bucket --bucket finansecure-terraform-state 2>/dev/null || \
          aws s3api create-bucket \
            --bucket finansecure-terraform-state \
            --region ${{ env.AWS_REGION }} \
            --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
          
          aws s3api put-bucket-versioning \
            --bucket finansecure-terraform-state \
            --versioning-configuration Status=Enabled
          
          aws s3api put-bucket-encryption \
            --bucket finansecure-terraform-state \
            --server-side-encryption-configuration '{
              "Rules": [{
                "ApplyServerSideEncryptionByDefault": {
                  "SSEAlgorithm": "AES256"
                }
              }]
            }' || true
        continue-on-error: true

      - name: Create DynamoDB table for locks (if not exists)
        run: |
          aws dynamodb describe-table --table-name terraform-locks 2>/dev/null || \
          aws dynamodb create-table \
            --table-name terraform-locks \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST
        continue-on-error: true

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Initialize Terraform
        run: |
          cd iac/envs/dev
          terraform init

      - name: Plan Terraform
        id: plan
        run: |
          cd iac/envs/dev
          terraform plan -out=tfplan

      - name: Apply Terraform
        id: terraform
        run: |
          cd iac/envs/dev
          terraform apply -auto-approve tfplan
          terraform output -json > outputs.json
          echo "alb_dns_name=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

      - name: Update ASG with latest images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          ASG_NAME=$(cd iac/envs/dev && terraform output -raw asg_name)
          LAUNCH_TEMPLATE=$(cd iac/envs/dev && terraform output -raw launch_template_id)
          
          # Trigger ASG to use new launch template version
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name $ASG_NAME \
            --launch-template LaunchTemplateId=$LAUNCH_TEMPLATE,Version='$Latest'
          
          # Start instance refresh
          aws autoscaling start-instance-refresh \
            --auto-scaling-group-name $ASG_NAME \
            --preferences '{"MinHealthyPercentage": 90, "InstanceWarmupSeconds": 300}'

      - name: Wait for instances to be healthy
        run: |
          ASG_NAME=$(cd iac/envs/dev && terraform output -raw asg_name)
          for i in {1..60}; do
            HEALTHY=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names $ASG_NAME \
              --query 'AutoScalingGroups[0].Instances[?HealthStatus==`Healthy`] | length(@)' \
              --output text)
            DESIRED=$(cd iac/envs/dev && terraform output -raw asg_desired_capacity || echo "1")
            
            if [ "$HEALTHY" -ge "$DESIRED" ]; then
              echo "All instances healthy!"
              break
            fi
            echo "Healthy instances: $HEALTHY / $DESIRED"
            sleep 10
          done

      - name: Test application health
        run: |
          ALB_DNS=$(cd iac/envs/dev && terraform output -raw alb_dns_name)
          for i in {1..30}; do
            if curl -f http://$ALB_DNS/health; then
              echo "Application is healthy!"
              exit 0
            fi
            echo "Attempt $i/30 - waiting for app to be ready..."
            sleep 10
          done
          echo "Application health check failed!"
          exit 1

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const outputs = JSON.parse(fs.readFileSync('iac/envs/dev/outputs.json', 'utf8'));
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## DEV Deployment Summary
              
              ✅ Deployment successful!
              
              **Application URLs:**
              - Application: ${outputs.application_url.value}
              - Health Check: ${outputs.healthcheck_url.value}
              
              **Infrastructure:**
              - VPC ID: ${outputs.vpc_id.value}
              - ASG: ${outputs.asg_name.value}
              - ALB DNS: ${outputs.alb_dns_name.value}`
            });

  # ==================================================
  # Job: Deploy PROD
  # ==================================================
  deploy-prod:
    name: Deploy to PROD
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'prod'
    needs: build
    environment:
      name: prod
      url: https://${{ steps.terraform.outputs.application_url }}
    
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_PROD }}
          role-session-name: github-actions-deploy-prod

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Initialize Terraform
        run: |
          cd iac/envs/prod
          terraform init

      - name: Plan Terraform
        id: plan
        run: |
          cd iac/envs/prod
          terraform plan -out=tfplan

      - name: Apply Terraform (with confirmation)
        id: terraform
        env:
          TF_VAR_postgres_password: ${{ secrets.PROD_POSTGRES_PASSWORD }}
          TF_VAR_jwt_secret: ${{ secrets.PROD_JWT_SECRET }}
          TF_VAR_database_password: ${{ secrets.PROD_DATABASE_PASSWORD }}
          TF_VAR_db_connection_string: ${{ secrets.PROD_DB_CONNECTION_STRING }}
        run: |
          cd iac/envs/prod
          terraform apply -auto-approve tfplan
          terraform output -json > outputs.json
          echo "application_url=$(terraform output -raw application_url)" >> $GITHUB_OUTPUT
          echo "alb_dns_name=$(terraform output -raw alb_dns_name)" >> $GITHUB_OUTPUT

      - name: Update ASG with latest images
        run: |
          ASG_NAME=$(cd iac/envs/prod && terraform output -raw asg_name)
          LAUNCH_TEMPLATE=$(cd iac/envs/prod && terraform output -raw launch_template_id)
          
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name $ASG_NAME \
            --launch-template LaunchTemplateId=$LAUNCH_TEMPLATE,Version='$Latest'
          
          aws autoscaling start-instance-refresh \
            --auto-scaling-group-name $ASG_NAME \
            --preferences '{"MinHealthyPercentage": 90, "InstanceWarmupSeconds": 300}'

      - name: Wait for instances (PROD)
        run: |
          ASG_NAME=$(cd iac/envs/prod && terraform output -raw asg_name)
          for i in {1..120}; do
            HEALTHY=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names $ASG_NAME \
              --query 'AutoScalingGroups[0].Instances[?HealthStatus==`Healthy`] | length(@)' \
              --output text)
            DESIRED=$(cd iac/envs/prod && terraform output -raw asg_desired_capacity || echo "3")
            
            if [ "$HEALTHY" -ge "$DESIRED" ]; then
              echo "All instances healthy!"
              break
            fi
            echo "Healthy instances: $HEALTHY / $DESIRED"
            sleep 10
          done

      - name: Verify PROD application
        run: |
          ALB_DNS=$(cd iac/envs/prod && terraform output -raw alb_dns_name)
          for i in {1..30}; do
            if curl -f https://$ALB_DNS/health; then
              echo "Production application is healthy!"
              exit 0
            fi
            echo "Attempt $i/30 - waiting for app..."
            sleep 10
          done
          exit 1

      - name: Create deployment notification
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const outputs = JSON.parse(fs.readFileSync('iac/envs/prod/outputs.json', 'utf8'));
            github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'production',
              required_contexts: [],
              auto_merge: false,
              description: 'Production deployment completed'
            });

      - name: Post deployment summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? '✅' : '❌';
            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `## PRODUCTION Deployment ${status}
              
              **Status:** ${{ job.status }}
              **Timestamp:** ${new Date().toISOString()}
              **Workflow:** [View Details](${context.payload.repository.html_url}/actions/runs/${context.runId})`
            });
